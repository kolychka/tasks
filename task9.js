/**
 * Дана последовательность интервалов.
 * Нужно объединить те, которые имеют пересечения.
 */

// mergeIntervals([[4, 8], [3, 5], [1, 2], [7, 12]]) // [[3, 12], [1, 2]] => [[3, 12], [1, 2]]
// mergeIntervals([[3, 4], [1, 2], [4, 5], [2, 3]]) // [[1, 5]]
// [1, 2], [3, 5], [4, 8], [7, 12]
const task9 = (array) => {
    // Если входной массив массивов с длиной меньше 2 то возвращаем изначальный массив
    if (array.length < 2) return array;

    // Сначала сортируем массив по возрастанию первых элементов каждого подмассива
    array.sort((a, b) => a[0] - b[0]);

    // Изначальные значения для нового массива и изменяемой переменной с предыдущим значением
    const newArray = [];
    let prev = array[0];

    // начинаем цикл со второго элемента массива, т.к. 1-ый у нас находится изначально
    for (let i = 1; i < array.length; i++) {
        // Если второй элемент предыдущего значения >= второму элементу текущего (итерируемого) значения
        // то добавляем в изменяемую переменную хранящую предыдущее значение
        if (prev[1] >= array[i][0]) {
            prev = [prev[0], Math.max(prev[1], array[i][1])];
        } else {
        // Если вышестоящее условие не проходит то просто пушим в новый массив значение изменяемой переменной 
        // с предыдущим значением и назначаем этой переменной значение текущего итерируемого элемента
            newArray.push(prev);
            prev = array[i];
        }
    }

    newArray.push(prev);

    return newArray;
}

export default task9;
